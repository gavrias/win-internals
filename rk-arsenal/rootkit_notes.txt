ROOTKIT DESIGN
--------------

Principles
----------
1. Concealment
2. Command & Control (C & C)
3. Surveillance

Example characteristics:
------------------------
1. Avoid detection - eg: install under folder "System Volume Information"
2. Avoid detection again - eg: create 2/3 subfolders under it , deny access to anyone and use system -real-like- folder names, eg: F7S0E6C3-38EE-llDl-8SES-OOC04FC29SEE 
3. Avoid detection again - eg: change timpestamps with the "touch" program. You can use this to match the recycle bins timestamps (touch -g flag)
4. Persistence - eg: Put files under system32, with usual legit executables (eg: qttask.exe).
5. Persistence - eg: Install as a service, under a legit-like name: LdmSvc (Local Disk Management Service)
6. Persistence - eg: Make other services depend on it, tamper registry keys (HKLM\SYSTEM\CurrentControlSet\Services) DependOnService.
7. Securing machine - eg: Shut off default hidden shares etc
8. Persistence - eg: Installation of MSUS (Software Update Services), make domain group policy to point domain members at rogue - fake server.
9. Dive deeper - eg: Using MSUS to distribute remote administration (DameWare), install the rootkit.msi files as updates to the other machines! trusted!
10. C & C - eg: via ftp/ssh etc.

Design goals:
-------------
Don't stick on implementation details. Design with regard to the end-goal/result, not the means. Eg: There are many ways to conceal ur presence, not only to hide the process from the process tree.
=======================================

IA-32 Architecture
------------------
IA-32 processors read and write 4 bytes at a time (32 bit)

Memory Models
-------------
Flat: seeming to be a one by one correspondence between the virtual and the physical memory
Segmented: Memory address has 2 parts, segment selector and effective (offset) address.

Modes of Operation
------------------
(System Management Mode - SMM: used to execute special code embedded in the firmware - eg: emergency shutdown, power management)
Real mode: 16-Bit execution environment. When a IA-32 machine powers up, it does so at real mode. All BIOS functions are in real mode. Everything is possible
Protected mode: After the machine boots, the OS sets up the necessary bookkeeping data structures and then switches the processor to protected mode.

Both modes are instances of the segmented model.

Interrupts
----------
Interrupt is some sort of event that triggers the execution of a special type of procedure called "Interrupt service Routine" (ISR), aka "interrupt handler". Each type of event is assigned an integer value that associates with the appropriate ISR. 
In real mode the first kilobyte of memory 0x00000-0x003FF is occupied by a special data structure, called Interrupt Descriptor (Vector in real mode) Table, IDT. IDT maps interrupts to ISR's that handle them. Specifically they store a series of "interrupt descriptors" that designate where to locate the ISRs in memory.

Types of Interrupts
-------------------
There are 3 types of interrupts: hardware, software, exceptions. Hardware (external) interrupts are generated by external devices. Hardware are maskable and unmaskable. Maskable can be disabled by clearing the IF flag, via the CLI instruction. Interrupt 8 and 9 are good examples of maskable. A nonmaskable interrupt cannot be disabled, the processor must act on this type.
Software (internal) are implemented in a program using the INT instruction (eg INT 0x21H in linux). The INT instruction clears the TF (Trap Flag) and interrupt enable flag (IF), pushes FLAGS, GS, IP registers onto the stack, jumps to the address of the ISR specified by the interrupt descriptor, executes until it reaches the IRET instruction.
Exceptions are generated when the processor detects an error while executing an instruction. 3 types of exceptions: Fault (eg divide by 0) where the state of the program can be restored to what it was before the exception. Traps, no instruction restart is possible. Breakpoint and overflow interrupts are examples of faults. Aborts, are hopeless.

Protected mode:
---------------
Extra registers:
CR0 to CR4 (Control Registers)
GDTR (Global Descriptor Table Register)
LDTR (Local Des...)
IDTR (Interrupt Descriptor Table Register)

Also, important, the CS (Code Segment) register is the only register that cannot be set explicitly, CS's contents must be set implicitly with instructions that transfer program control (JMP, CALL, INT, RET, IRET, SYSENTER, SYSEXIT)

Protected-mode Segmentation
---------------------------
2 things -> Segmentation and Paging (Optional feature)
Segmentation: Segment selector is 16bits in size and the effective (offset) address is 32bits. The segment selector references an entry in a table that describes a segment in linear address space (??). Instead of storing the address of a segment in physical memory, the segment selector refers to a binary structure that contains details about a segment in linear address space. This table is the "descriptor table" and its contents are the "segment descriptors". A "segment descriptor" stores metadata about a segment in linear address space (access rights, size, 32-bit base address, etc). The 32bit base address, extracted from the segment descriptor by the processor is then added to the offset to yield a linear address.

There are 2 types of descriptor tables: "global descriptor tables (GDT)" and "local descriptor tables (LDT)". GDT is mandatory, every IA-32 OS must create one on startup and typically it will be shared for all tasks. LDT is optional and can be used by a single task or a group of related tasks. The FIRST ENTRY of the GDT is always empty. This entry is called "null segment descriptor". The selector that indexes this GDT entry is known as a "null selector".

The special register used to hold the base GDT address is the GDTR (48 bytes size). The lowest 16 bits (0 to 15) store the size of the GDT. The remaining 32 bits store the base linear address of the GDT. Special registers mean special instructions: LGDT loads (writes) a value on the GDTR and the SGDT reads a stored value from GDTR. The LGDT is privileged (only run from the OS).

The segment selector is a 16bit value. The highest 13 bits (15 to 3) are an index to the GDT, so that the GDT stores at most 8.192 (2^13-1) segment descriptors. The bottom two bits define the "request privilege level" (RPL) of the selector. There are four possible values (00, 01, 10, 11) where 0 has the highest privilege and 3 the lowest. (page 59). 

The segment descriptor includes: 1. the address where the memory segment starts, 2. the Type of segment we are dealing with (code or data), access, and growth direction, 3. Description whether this is a system segment or an application segment, 4. DPL: descriptor privilege level -> ring0, 1, 2 or 3 such as a segment of DPL 0 is referred to as existing inside ring0. Typically the OS kernel exists and executes in ring 0 while applications at ring3. 

The "s flag" can be S=1 for code n data or S=0 for system segment descriptors. Code and data are the normal application segments, while system segment descriptors are used to jump to segments whose privilege level is greater than that of the current executing task (current privilege level, CPL). For example: when a user application invokes a system call which should be implemented in Ring 0, a system segment descriptor must be used.

For description regarding the Type flag settings see page 60. The read/write is described, the execution privileges, the expansion direction.

Protected-mode Paging
---------------------
When Paging is enabled, the linear address space is divided into fixed-size chunks of memory called "pages" (they can be 4kb, 2mb, or 4mb in size). These pages can be mapped either on physical memory or on the disk. If a program references a byte in memory which is mapped on the disk, the processor generates a "page fault" (#PF). That signals the OS that it should load this page on to the physical memory. The slot in physical memory which the page will be loaded is called "page frame".

In the absence of paging, a linear address is a physical address. When paging is enabled, a linear address is split into three subfields. The highest 10 bits (31 to 22) are an index to the "page directory", the middle 10 bits (21 to 12) are an index to the "page table". The entries in the page table, arranged sequentially as an array are known as "page table entries" (PTEs). Because the value we use to specify an index into the page table is 10 bits in size, a page table can store at most 1024 PTEs. The final 12 bits (11 to 0) are an offset to the physical page of memory.

The page directory is an array structure. Each entry is knowns as "page directory entry" (PDE). The physical address of the first byte of the page directory is stored at the CR3 register, which in turn is aka "page directory base register" PDBR

PDEs: Each one contains the base physical address (not the linear) of a secondary array structure known as a page table. It stores the physical address of the first byte of that table.

PTEs: Each one stores the physical address of the first byte of a page of memory (physical adress). The first field (0 to 11) is added to the physical base address provided by the PTE to yield the address of a byte at physical.

PDEs and PTEs are shown at page 63.
 
Each process is given its own copy of CR3 (register that stores the physical address of the first byte of the PDT), so its possible for two processes to have the same linear address and yet have that address mapped to a different physical address for each process.

Protection through Segmentation
-------------------------------
* Limit checks - Ensure that a program doesn't access memory that isn't there
* Segment type checks - They use the S flag and Type field (see above) so that eg: you cant write on a code segment (CS register) 
* Privilege-level checks - They prevent a process running in an outer ring from arbitrarily accessing segments that exist inside an inner ring. For implementation 3 different privilege indicators are used: CPL, RPL, DPL. The "Current Privilege Level" is essentially the RPL value of the selectors currently stored in the CS and SS registers of an executing process. The CPL of the program is normally the privilege level of the current code segment. The CPL can change when a far jump or far call is executed. Priv level checks are invoked when a program attempts to access data in another segment or transfer program control by making an inter-segment jump. To access data in another segment, the selector for the data segment must be loaded into a stack-segment register (SS) or data-segment register (DS, ES, FS, GS). When accessing data in another segment the processor checks to make sure that the DPL is greater than or equal to both the RPL and the CPL. If it is, then it wil lload the DS register with the Segment Selector of the Data Segment... more at page 69.
* Restricted-instruction checks - verify that a program isn't trying to use instructions that are restricted to a lower CPL value.

Gate Descriptors (p 70)
----------------
Gate Descriptors are system descriptors (the S flag in the segment descriptor is clear). Gate descriptors offer a way for programs to access code segments possessing different privilege levels with a certain degree of control. Types are:
*call-gate descriptors - They live in GDT. Essentially, what they are is a descriptor in the GDT pointing to another descriptor in the GDT which then points to a code segment. (p 72)
*interrupt-gate descriptors - They live in IDT
*trap-gate descriptors - They live in IDT.

Protected mode Interrupt Tables (IDT)
-------------------------------------
Interrupt Descriptor Table: stores an array of 64-bit gate descriptors. The IDT may reside anywhare in linear addr space. The 32-bit base address of the IDT is stored in the 48-bit IDTR register (bits 16 to 47). The size limit of the IDT, in bytes, is stored in the lower word of the IDTR register (bits 0 to 15). The size limit is a byte offset from the base address of the IDT to the last entry in the table, such that an IDT with N entries will have its size limit set to 8(N-1). General-protection exception (#GP) is generated if a vector beyond the size limit is referenced.

There are 256 interrupot vectors possible, 0 through 31 are reseved by the IA-32 processor for machine-specific exceptions and interrupts. The rest can be used to service user-defined interrupts. (p 74)

Protection Through Paging
-------------------------
Page-level checks occur before the memory cycle is initiated. 
Paging is optional: Even if paging has been enabled, you can disable paging-level memory protection by (... p 75); this makes all memory pages writeable, assigns all of them the user privilege level and allows supervisor-level code to wirte to user-levle pages that have been marked as read only.

SUMMARY
------- 
In the end, there are a handful of index tables that the os creates and populates with special data structures. These data structures define both the layout of memory and the rules that the processor checks against when performing a memory access. If a rule is violated, the processor throws an exception and invokes a routine defined by the operating system to handle the event. page 77 for nice table and figure
===================================================

Windows System Architecture
---------------------------
32bit max 4GB of memory. PAE can go more.
To enable PAE at Windows 2008 and later use "bcdedit /set PAE ForceEnable"
At older systems like Win 2003, the "/PAE" switch should be added at the boot.ini file

Data Execution Prevention (DEP)
-------------------------------
*Hardware-enforced: DEP is enabled for both the OS and user apps (Only functions when PAE has been enabled)
*Software-enforced: DEP is enabled only for user apps

"bcedit /set nx AlwaysOn" -> sets hw enforced DEP for contemporary (modern) systems
"/noexecute=alwayson" -> sets hw enforced DEP for Win 2003 at its boot.ini file
These 2 commands also enable PAE if the OS supports it

Address Windowing Extensions (AWE)
----------------------------------
AWE is an MS specific feature (unlike PAE which is built-in IA-32) for increasing the ammount of memory that an application can access. AWE is an API, declared in "winbase.h", which allows a program using the API to access an amount of physical memory that is greater than the limit placed on by its linear address space. See page 83 for AWE win32 routines.

Pages, Page frames and Page Frame Numbers
-----------------------------------------
Page: Contiguous region in linear address space and in IA-32 can be 4 KB, 2 MB or 4 MB in size (its almost always 4 KB). Thre is NO PHYSICAL LOCATION associated with a page.
Page Frame: A specific location in PHYSICAL memory where a page is stored when it resides in RAM.
Page Frame Number (PFN): Represents the physical address of this location.

Eg: 4 KB pages with PAE not enabled, the PFN is a 20-bit value (i.e., 0x12345). This 20-bit unsigned integer value represents a 32-bit physical address by assuming the 12 least significant bits are zero (0x12345 is treated like 0x12345000). So -> PAGES ARE ALIGNED ON 4 KB BOUNDARIES, such that the address identified by a PFN is always a multiple of 4.096

Memory Protection
-----------------
As we saw there are 2 kinds of protections (segmetation and paging(optional)) at IA-32. Windows tends to rely more on paging than it does segmetation. The elaborate four-ring model realized through segment privilege parameters (CPL, RPL, DPL) is eschewed in favor of a simpler two-ring model where executable code in Windows is either running at the supervisor level (kernel mode) or at the user level (user mode). The distinction relies mostly in the U/S bit in the system's PDEs and PTEs. 

FIGURE 3-5 @ page 101!!

Major players of win architecture **KERNEL MODE COMPONENTS**:
-------------------------------------------------------------
HAL (Hardware Abstraction Layer): The hal is used to insulate the hardware from the os. It wraps up machine-specific details and provides the interface to "talk" with the hardware. Its then presumably more portable. The dll that represents HAL is usually hal.dll. For PCs is hal.dll, for PCs that provide an ACPI (advanced configuration and power interface) the HAL is implemented by a file named halacpi.dll (halmacpi.dll for ACPI pcs with multiple processors). In general HAL is represented by a hal*.dll which resides in %windir%\system32 folder.

Bootvid.dll: Offers primitive VGA support for the boot phase. This driver can be disabled by "bcdedit.exe quietboot" OR the "/noguiboot" flag in the boot.ini file.

Ntoskrnl.exe: The core of Windows OS. There are 2 layers which it implements its functionality: executive and kernel. Executive implements the system call interface and the major OS components (I/O manager, memory manager, process manager, thread manager). The kernel mode device drivers will be normally layered between the HAL and the Executive's I/O manager. The kernel implements low level routines (syncrhonization, thread scheduling, interrupt servicing) that the executive builds upon to provide higher level services. SEE TABLE 3-4  @ page 102 for specific ntoskrnl versions regarding to different architectures

win32k.sys: This kernel mode driver provides the basic GUI services (user and graphics device interface - GDI). Unlike other OSes windows pushes most of its GUI code to the kernel for speed.

for each of these you can use "dumpbin /imports bootvid.dll" to see the routines that one imports from others. Eg at ntoskrnl.exe we can see the low lvl HAL.dll functions which are imported:
68 READ_PORT_ULONG
6D WRITE_PORT_UCHAR
6F WRITE_PORT_USHORT
6E WRITE_PORT_ULONG
27 HalInitializeProcessor
3D HalSetRealTimeClock
 D HalCalibratePerformanceCounter
59 KeRaiseIrqlToSynchLevel
40 HalStartNextProcessor
2D HalQueryMaximumProcessorCount
30 HalRegisterDynamicProcessor
3F HalStartDynamicProcessor
5D KeStallExecutionProcessor
33 HalRequestClockInterrupt
23 HalHandleNMI
 B HalBeginSystemInterrupt
13 HalEndSystemInterrupt
12 HalEnableInterrupt
69 READ_PORT_USHORT
3C HalSetProfileInterval
41 HalStartProfileInterrupt
42 HalStopProfileInterrupt
 E HalClearSoftwareInterrupt
34 HalRequestIpi
10 HalDisableInterrupt
43 HalSystemVectorDispatchEntry
5E KeTryToAcquireQueuedSpinLock
53 KeFlushWriteBuffer
1D HalGetInterruptTargetInformation

USER MODE COMPONENTS
--------------------
Environmental subsystem is a set of binaries, running in user mode, that allow applications written to utilize a particular environment/API to run.

The Windows subsystem consists of three basic components:
	* User-mode Client-Server Runtime Subsystem (csrss.exe)
	* Kernel-mode device driver (win32k.sys)
	* user-mode DLLs that impelemnt the subsystem's API

The csrss plays an important role in the management of the user mode processes and threads. 
The interface that the Windows subsystem exposes to user applications (the windows API) looks like the Win32 API and is implemented as a collection of DLLs (e.g. kernel32.dll, advapi32.dll, user32.dll, gdi.dll, shell32.dll rpcrt4.dll, etc). If a Windows API cannot be implemented entirely in user space, and needs to access services provided by the executive, it will invoke code in the ntdll.dll library to REROUTE program control to code in ntoskrnl.exe.

To sum UP: The Windows subsystem is the one that provides the Windows API (part of which it is the Win32 API) 

The Native API
--------------
The features that an operating system offers to user-mode applications are defined by a set of ROUTINES called the "system call interface". These are the building blocks used to create user-mode APIs like the ANSI C standard library.
The system call interface in Windows is called the "native API of Windows". So the native API of Windows is closed source and in part undocummented. Rather than access operating system services through the system call interface (like linux with syscalls like read() write() etc) the architects of Windows have decided to vail them behind another layer of code which is the Windows API.

Hardware and syscall mechanism
------------------------------
At older pcs, such as Pentium II, the INT 0x2E instruction is used to make the syscalls. More recent IA-32 processors, Windows relieves the IDT (the interrupt descriptor table which holds the ISRs - interrupt service routines, the numbers each syscall refers to if you dont remember) of this duty in favor of using the special-purpose SYSENTER instruction to make the jump to kernel space code. Hence, most contemoporary installation of windows use the IDT to respond to hardware-generated signals and handle processor exceptions.

The ISR that handles the interrupt 0x2E is a routine named KiSystemService. This is the "system service dispatcher", which uses the information passed to it from user mode to locate the address of a native API routine and invoke the native API routine.

System Call data structures
---------------------------
When the INT 0x2E instruction is used to invoke a system call, the "system service number" (aka dispatch ID) that uniquely identifies the syscall is placed on the EAX register. Back at W2k the code to implement was something like:

ntdll!NtDeviceIoControlFile:
	mov eax, 38h ;dispatch ID/system service number
	lea edx, [esp + 4]
	int 2Eh	; or int 0x2E, invoke the syscall with dispatch id 0x38
	ret 28h

The syscall above (NtDeviceOiControlFile) resides at the ntdll.dll. The first thing it does, is to load the system service number. Next an address for a value on the stack is stored in EDX and then the interrupt is executed.

The SYSENTER instruction
------------------------
Now most machines use the SYSENTER instruction to jump from user mode to kernel mode. BEFORE SYSENTER is invoked, three 64-bit "machine specific registers - MSRs" MUST be populated so the processor knows both where it should jump to and where the kernel mode stack is located (in the event that the user-mode stack needs to be copied over).
See page 109, table 3-7 for the specific MSRs


------_____ |----------------------------------| _____-----
		   \|The System Service Dispatch Tables|/
			|----------------------------------|

The kernel's system service dispatcher (i.e. KiSystemService) ends up being invoked when user-mode code executes INT 0x2E or SYSENTER. It uses the system service number to index an entry in an address lookup table. The system service number is a 32-bit value. The first 12 bits (0 to 11) indicate which system service call will be invoked. Bits 12 and 13 specify ONE OF FOUR possible "service descriptor tables". Fig 3-6 @ page 111.

These service descriptor tables contain substructures known as "System Service Tables" (SSTs). 
There are two service descriptor tables which contain symbols in kernel space, that means (?) 2 usable SDTs: KeServiceDescriptorTable (exported by ntoskrnl.exe, u can verify via dumpbin). The other table, the KeServiceDescriptorTableShadow is visible only within the confines of the executive.

If the bits 12 and 13 of the system service number are 0x00 (this means that the system service numbers range from 0x0000 to 0x0FFF) then the KeServiceDescriptorTable is used. Else if bits 12 and 13 of the system service number are 0x01 (the system service numbers range from 0x1000 - 0x1FFF), then the KeServiceDescriptorTableShadow is to be used.

so a (with exported symbols at kernel space) SDT is either: KeServiceDescriptorTable OR KeServiceDescriptorTableShadow
 
SDTs contain SSTs. SSTs are of this form:

typedef struct _SYSTEM_SERVICE_TABLE
{
	PDWORD	serviceTable;		//array of function pointers (SSDT)
	PDWORD	field2;				//not used in Windows free build
	DWORD	nEntries;			//number of function pointers in SSDT
	PBYTE	argumentTable;		//array of byte counts
}SYSTEM_SERVICE_TABLE;

the serviceTable is a pointer to the first element of an array of linear addresses (array of function pointers) where each address is the entry point of a routine in kernel space. This array of linear addresses is aka System Service Dispatch Table (SSDT).

the nEntries, specifies the number of elements in the SSDT array.
more info at page 112.

IMPORTANT!: The first 16 bytes of the KeServiceDescriptorTable is an SST that its SSDT points at the Windows Native API. This is the core system data structure.
			it has 391 routines (nEntries = 0x187) -- more info at page 112!
			
			The first 32 bytes of the KeServiceDescriptorTableShadow has two SSTs. The first is a copy of the KeServiceDescriptorTable. The second SST describes the SSDT for the user and GDI routines of win32k.sys kernel mode driver. There are 772 routines that handle that, all the Windows GUI.

So we got so far: SYSENTER/INT 0x2E ---> MSRs populated ---> KiSystemService invoked ---> SSN (32bit value) used from the KiSystemService ---> One SDT is used ---> SST ---> SSDT ---> Windows API routine

---------------------------
Enumerating the native API
---------------------------
We know where the native API SSDT is located and how big it is: REMINDER -> The first 16 bytes of the KeServiceDescriptorTable, the first SSTs SSDT points to it.
All of the routines names, whit the exception of xHalLoadMicrocode() system call, all begin with the prefix "Nt".

We use dumpbin.exe for the ntdll.dll exported functions. We notice that there are 393 Nt*() exported functions. The 2 NtGetTickCount() and NtCurrentTeb() are the only user space ones.
We also notice that each Nt*() has a matching Zw*() function with the same name. At user space Nt and Zw are the call the same function. When invoked at kernel space, Nt and Zw dont call the same functions: check page 115 for this. den katalabenw ZwReadfile() kai NtReadFile() diafores.

LIFE CYCLE OF A SYSTEM CALL!
--------------------------
GO PAGE 116!! it owns!!
figre 3-7!

The Boot Process!
=-=-=-=-=-=-=-=-=
1. Startup for BIOS firmware:
	a. Power-On Self Test(POST): Performs low-level hw checks, eg: on board memory available, storage device enumeration.
	b. Search bootable devices for a boot sector. If the bootable device is an hd, this boot sector is a Master Boot Record (MBR). The MBR is the first sector of the disk and is normally written there by the Windows setup program. It contains both instructions (boot code) and a partition table.
	The MBR boot code searches for the "active partition" (bootable partition, aka system volume) and then loads this partition's boot sector into memory. The active partition's boot sector, aka volume boot record (VBR), is the first sector of the partition and it also contains a modest snippet of boot code. See fig 3-9, p. 125
	If the first bootable device encountered by the BIOS is not a hard disk (a bootable DVD) the BIOS will load that device's VBR into memory. Thus regardless what happens, the VBR ends up being executed.
	c. The boot code in the VBR locates the 16-bit boot manager program whose path is %SYSTEMDRIVE%\bootmgr. 
	d. The bootmgr is actually two executables that have been concatenated. The first-part of the bootmgr (16-bit stub) executes in REAL mode, just like the code in MBR and VBR. It sets up the necessary data structures, switches the machine into protected mode, and then loads the protected mode version of the boot manager into memory.

ROOTKIT BASICS
=-=-=-=-=-=-=-=-=
Configuring cdb.exe
-------------------
Symbolf files are used to store the programmatic metadata of an application. This metadata is archived according to a binary specification known as the "program database format" (.pdb files).
